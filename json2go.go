package json2go

import (
	"bytes"
	"fmt"
	"github.com/Lofanmi/pinyin-golang/pinyin"
	"github.com/tidwall/gjson"
	"go/format"
	"regexp"
	"strconv"
	"strings"
	"unicode"
)

// 整体大类型
const (
	V    = "Value"
	V1   = "[]Value"
	V2   = "[][]Value"
	O    = "Object"
	O1   = "[]Object"
	O2   = "[][]Object"
	Nil1 = "[]"
	Nil2 = "[][]"
)

// Value细分的类型
const (
	VTypeString  = "string"
	VTypeBool    = "bool"
	VTypeFloat64 = "float64"
	VTypeInt     = "int"
	VTypeInt64   = "int64"
	VTypeAny     = "interface{}"
	// 属性为null的，数组为空的，都先用这个表示。最后再进行属性合并的时候会用到
	VTypeNil = "nil"
)

const (
	DefaultName = "AutoGenerated"
	MaxInt32    = 1<<31 - 1
	MinInt32    = -1 << 31
)

type Pair struct {
	// 字段名称
	K string
	// 类型的值
	V string
	// 所属大类型
	T string
	// 备注
	C string
}

type Obj struct {
	name  string
	elems []*Pair
}

// https://github.com/golang/lint/blob/master/lint.go
var commonInitialisms = map[string]struct{}{
	"ACL":   {},
	"API":   {},
	"ASCII": {},
	"CPU":   {},
	"CSS":   {},
	"DNS":   {},
	"EOF":   {},
	"GUID":  {},
	"HTML":  {},
	"HTTP":  {},
	"HTTPS": {},
	"ID":    {},
	"IP":    {},
	"JSON":  {},
	"LHS":   {},
	"QPS":   {},
	"RAM":   {},
	"RHS":   {},
	"RPC":   {},
	"SLA":   {},
	"SMTP":  {},
	"SQL":   {},
	"SSH":   {},
	"TCP":   {},
	"TLS":   {},
	"TTL":   {},
	"UDP":   {},
	"UI":    {},
	"UID":   {},
	"UUID":  {},
	"URI":   {},
	"URL":   {},
	"UTF8":  {},
	"VM":    {},
	"XML":   {},
	"XMPP":  {},
	"XSRF":  {},
	"XSS":   {},
}

// json字符串转对象，在前端进行了json5格式验证和格式化
func Generate(jsonStr string, tags []string, commentFlag bool) (string, error) {
	// 解析JSON
	parsedJson := gjson.Parse(jsonStr)
	all := make([]*Obj, 0)
	if parsedJson.IsArray() {
		parsedJson.ForEach(func(key, value gjson.Result) bool {
			if value.IsObject() {
				Ite(&all, DefaultName, gjson.Parse(value.Raw), commentFlag)
			}
			return true
		})
	} else {
		Ite(&all, DefaultName, parsedJson, commentFlag)
	}
	// 合并多个name相同的对象，并且格式化数据类型
	all = mergeAndFormatObj(all)
	// 优化输出顺序
	all = reOrder(all)
	// 格式化前name；格式化后name
	nameMap := make(map[string]string)
	// 转换后的name，如果重名了，后面加数字表示
	nameCount := make(map[string]int)
	var buff bytes.Buffer
	for i, obj := range all {
		buff.WriteString(fmt.Sprintf("type %s struct {\n", formatKey(nameMap, nameCount, obj.name)))
		for _, e := range obj.elems {
			if e.C != "" {
				buff.WriteString(e.C + "\n")
			}
			buff.WriteString(fmt.Sprintf("%s %s %s\n", formatKey(nameMap, nameCount, e.K), formatType(nameMap, nameCount, e.V, e.T), formatTag(e.K, tags)))
		}
		if i == len(all)-1 {
			buff.WriteString("}")
		} else {
			buff.WriteString("}\n\n")
		}
	}
	source, err := format.Source(buff.Bytes())
	if err != nil {
		fmt.Println(err)
		return buff.String(), err
	}
	return string(source), nil
}

// 对输出的struct重排序
func reOrder(all []*Obj) []*Obj {
	if len(all) == 0 {
		return all
	}
	cache := make(map[string]*Obj)
	// 最外层的对象名
	var last *Obj
	for _, obj := range all {
		cache[obj.name] = obj
		if obj.name == DefaultName {
			last = obj
		}
	}
	order := make([]string, 0, len(all))
	orderMap := make(map[string]struct{}, len(all))
	reOrderObj(&order, orderMap, last, cache)
	var result []*Obj
	for _, o := range order {
		result = append(result, cache[o])
	}
	return result
}

func reOrderObj(order *[]string, orderMap map[string]struct{}, obj *Obj, cache map[string]*Obj) {
	if _, ok := orderMap[obj.name]; !ok {
		orderMap[obj.name] = struct{}{}
		*order = append(*order, obj.name)
		elems := obj.elems
		for _, e := range elems {
			if e.T == O || e.T == O1 || e.T == O2 {
				reOrderObj(order, orderMap, cache[e.K], cache)
			}
		}
	}
}

// 对象的属性会受合并的影响，在这个阶段完成属性类型的设置
func mergeAndFormatObj(all []*Obj) []*Obj {
	result := make([]*Obj, 0)
	cache := make(map[string]*[]*Obj)
	var order []string
	for _, o := range all {
		if _, ok := cache[o.name]; !ok {
			arr := make([]*Obj, 0)
			cache[o.name] = &arr
			order = append(order, o.name)
		}
		arr := cache[o.name]
		*arr = append(*arr, o)
	}
	for _, n := range order {
		arr := *cache[n]
		obj := mergeAndFormatField(n, arr)
		result = append(result, obj)
	}
	return result
}

// array只有一个，则只进行类型格式化；array大于1，则先进行合并，然后再进行格式化
func mergeAndFormatField(name string, array []*Obj) *Obj {
	obj := &Obj{
		name: name,
	}
	if len(array) == 1 {
		o := array[0]
		for _, e := range o.elems {
			arr := make([]*Pair, 0)
			arr = append(arr, e)
			tType, vType := getFieldType(arr)
			e.T = tType
			e.V = vType
			obj.elems = append(obj.elems, e)
		}
		return obj
	}
	cache := make(map[string]*[]*Pair)
	var order []string
	for _, o := range array {
		for _, e := range o.elems {
			if _, ok := cache[e.K]; !ok {
				arr := make([]*Pair, 0)
				cache[e.K] = &arr
				order = append(order, e.K)
			}
			arr := cache[e.K]
			*arr = append(*arr, e)
		}
	}
	for _, n := range order {
		arr := *cache[n]
		tType, vType := getFieldType(arr)
		pair := arr[0]
		pair.T = tType
		pair.V = vType
		pair.C = mergeComment(arr)
		obj.elems = append(obj.elems, pair)
	}
	return obj
}

func mergeComment(arr []*Pair) string {
	comment := ""
	for _, p := range arr {
		if p.C != "" {
			comment = p.C
			break
		}
	}
	return comment
}

// 返回属性的类型，需要考虑大类型和小类型
func getFieldType(array []*Pair) (tType string, vType string) {
	var tArray []string
	var vArray []string
	for _, p := range array {
		tArray = append(tArray, p.T)
		vArray = append(vArray, p.V)
	}
	flag, tType := getFiledTType(tArray)
	if !flag {
		return tType, VTypeAny
	}
	if tType == O || tType == O1 || tType == O2 {
		for _, v := range vArray {
			if v != VTypeNil {
				// 对象类型的值，只有nil和对象名
				return tType, v
			}
		}
		// 兜底
		return tType, vArray[0]
	}
	// 判断value的类型
	vType = mergeVType(vArray)
	if vType == VTypeNil {
		vType = VTypeAny
	}
	return tType, vType
}

// 先判断大类型T是否是any，如果是则终止，如果不是，继续判断小类型
// 空类型如果可以存在，会被直接合并
func getFiledTType(array []string) (flag bool, tType string) {
	VFlag := false
	V1Flag := false
	V2Flag := false
	OFlag := false
	O1Flag := false
	O2Flag := false
	Nil1Flag := false
	Nil2Flag := false
	for _, t := range array {
		switch t {
		case V:
			VFlag = true
		case V1:
			V1Flag = true
		case V2:
			V2Flag = true
		case O:
			OFlag = true
		case O1:
			O1Flag = true
		case O2:
			O2Flag = true
		case Nil1:
			Nil1Flag = true
		case Nil2:
			Nil2Flag = true
		}
	}
	count := 0
	if VFlag {
		count++
	}
	if V1Flag {
		count++
	}
	if V2Flag {
		count++
	}
	if OFlag {
		count++
	}
	if O1Flag {
		count++
	}
	if O2Flag {
		count++
	}
	// 类型是any的情况
	if count > 1 || Nil1Flag && Nil2Flag {
		return false, V
	}
	if Nil1Flag && (VFlag || V2Flag || OFlag || O2Flag) {
		return false, V
	}
	if Nil2Flag && (VFlag || V1Flag || OFlag || O1Flag) {
		return false, V
	}
	if count == 0 {
		// 必然存在
		if Nil1Flag {
			return false, V1
		} else {
			return false, V2
		}
	}
	// 类型不是any
	if VFlag {
		return true, V
	}
	if V1Flag {
		// 不需要考虑Nil1Flag
		return true, V1
	}
	if V2Flag {
		return true, V2
	}
	if OFlag {
		return true, O
	}
	if O1Flag {
		return true, O1
	}
	return true, O2
}

// 格式化对象名，属性名，并且通过cache来解决全局重名问题
// 对象名不能重复；属性名要考虑多个对象之间的一致性，所以要保持全局统一的映射关系
func formatKey(nameMap map[string]string, nameCount map[string]int, key string) string {
	if e, ok := nameMap[key]; ok {
		return e
	}
	result := ""
	// 按下划线分割，每个片段的首字母大写
	split := strings.Split(key, "_")
	for i, str := range split {
		span := ""
		for j, v := range str {
			s := ""
			if isLetter(v) {
				s = string(v)
			} else if isDigit(v) {
				s = string(v)
			} else if unicode.Is(unicode.Han, v) {
				// 处理中文字符
				s = convert2Pinyin(string(v))
			}
			if s == "" {
				continue
			}
			if j == 0 {
				s = strings.ToUpper(s)
			}
			if i == 0 && span == "" {
				// 首字母如果是数字，就转换
				s = numToLetter(s)
			}
			span += s
		}
		span = convertInitialisms(span)
		result += span
	}
	result = convertInitialisms(result)
	// 判断是否重名
	if count, ok := nameCount[result]; ok {
		// 重名了，末尾加数字
		result = result + strconv.Itoa(count+1)
		nameCount[result] = count + 1
	} else {
		nameCount[result] = 0
	}
	nameMap[key] = result
	return result
}

func isLetter(r rune) bool {
	return r >= 'a' && r <= 'z' || r >= 'A' && r <= 'Z'
}

func isDigit(r rune) bool {
	return r >= '0' && r <= '9'
}

// 中文字符转拼音首字母，返回小写
func convert2Pinyin(s string) string {
	s = pinyin.NewDict().Abbr(s, "")
	return strings.ToLower(s)
}

func formatType(nameMap map[string]string, nameCount map[string]int, v string, t string) string {
	result := v
	if t == O {
		result = formatKey(nameMap, nameCount, v)
	} else if t == O1 {
		result = "[]" + formatKey(nameMap, nameCount, v)
	} else if t == O2 {
		result = "[][]" + formatKey(nameMap, nameCount, v)
	} else if t == V1 {
		result = "[]" + v
	} else if t == V2 {
		result = "[][]" + v
	}
	return result
}

func formatTag(key string, tag []string) string {
	result := "`"
	var array []string
	for _, t := range tag {
		s := fmt.Sprintf("%s:%q", t, key)
		array = append(array, s)
	}
	result += strings.Join(array, " ")
	result += "`"
	return result
}

func Ite(all *[]*Obj, name string, result1 gjson.Result, commentFlag bool) {
	// 需要记录每个对象的key和数据类型
	array := make([]*Pair, 0)
	cm := buildCommentMap(result1.Raw, commentFlag)
	result1.ForEach(func(key1, value1 gjson.Result) bool {
		if value1.Type == gjson.JSON {
			if value1.IsArray() {
				// 一维数组
				if value1.Raw == "[]" {
					array = append(array, &Pair{K: key1.String(), V: VTypeNil, T: Nil1, C: cm[key1.String()]})
					return true
				}
				result2 := gjson.Parse(value1.Raw)
				result2.ForEach(func(key2, value2 gjson.Result) bool {
					if value2.Type == gjson.JSON {
						if value2.IsArray() {
							// 二维数组
							if value2.Raw == "[]" {
								array = append(array, &Pair{K: key1.String(), V: VTypeNil, T: Nil2, C: cm[key1.String()]})
								return false
							}
							result3 := gjson.Parse(value2.Raw)
							result3.ForEach(func(key3, value3 gjson.Result) bool {
								if value3.Type == gjson.JSON {
									if value3.IsObject() {
										// [][]Object
										array = append(array, &Pair{K: key1.String(), V: key1.String(), T: O2, C: cm[key1.String()]})
										arrayObj := getArrayObj(value2.Raw)
										for _, obj := range arrayObj {
											Ite(all, key1.String(), obj, commentFlag)
										}
										return false
									}
								} else {
									// [][]Value
									array = append(array, &Pair{K: key1.String(), V: getJSONArrayType(&result3), T: V2, C: cm[key1.String()]})
									return false
								}
								return false
							})
						} else if value2.IsObject() {
							// []Object
							array = append(array, &Pair{K: key1.String(), V: key1.String(), T: O1, C: cm[key1.String()]})
							arrayObj := getArrayObj(value1.Raw)
							for _, obj := range arrayObj {
								Ite(all, key1.String(), obj, commentFlag)
							}
						}
					} else {
						// []Value
						array = append(array, &Pair{K: key1.String(), V: getJSONArrayType(&result2), T: V1, C: cm[key1.String()]})
					}
					return false
				})
			} else if value1.IsObject() {
				// Object
				array = append(array, &Pair{K: key1.String(), V: key1.String(), T: O, C: cm[key1.String()]})
				Ite(all, key1.String(), gjson.Parse(value1.Raw), commentFlag)
			}
		} else {
			// Value
			array = append(array, &Pair{K: key1.String(), V: getJSONType(value1), T: V, C: cm[key1.String()]})
		}
		return true
	})
	*all = append(*all, &Obj{
		name:  name,
		elems: array,
	})
}

// 支持单行备注，每次都是全量按行遍历，根据前缀\t的个数，来决定是否是最外层对象的备注
func buildCommentMap(raw string, commentFlag bool) map[string]string {
	m := make(map[string]string)
	if !commentFlag {
		return m
	}
	if !strings.Contains(raw, "//") {
		return m
	}
	// 判断 \t //
	reg := `^(\t*)\s*(//[\s\S]*)$`
	commentReg := regexp.MustCompile(reg)
	// 判断 \t k:v
	reg1 := `^(\t*)\"(\S+){1}\": ([\s\S]+){1},?$`
	kvReg := regexp.MustCompile(reg1)
	// 判断 \t k:v // comment
	reg2 := `^(\t*)\"(\S+){1}\": ([\s\S]+){1},?\s*(//[\s\S]*)$`
	kvcReg := regexp.MustCompile(reg2)
	firstKey := ""
	prefix := "-"
	result := gjson.Parse(raw)
	result.ForEach(func(key, value gjson.Result) bool {
		firstKey = key.Str
		return false
	})
	split := strings.Split(raw, "\n")
	// 判断第一个key的前缀，有几个\t
	for _, s := range split {
		resultKv := kvReg.FindStringSubmatch(s)
		if len(resultKv) == 4 {
			if resultKv[2] == firstKey {
				prefix = resultKv[1]
				break
			}
		}
		resultKvc := kvcReg.FindStringSubmatch(s)
		if len(resultKvc) == 5 {
			if resultKvc[2] == firstKey {
				prefix = resultKvc[1]
				break
			}
		}
	}
	if prefix == "-" {
		// 没有解析到key
		return m
	}
	k1 := prefix
	k2 := prefix + "\t"
	for i := 0; i < len(split); i++ {
		s := split[i]
		// 以\t开头的，先通过前缀筛选数据，然后在进行正则匹配
		if strings.HasPrefix(s, k1) && !strings.HasPrefix(s, k2) {
			// 1.在行的上一行进行备注，如  // 独立一行的备注
			resultComment := commentReg.FindStringSubmatch(s)
			if len(resultComment) == 3 {
				// 判断下一行是不是json的kv
				if i <= len(split)-2 {
					next := split[i+1]
					resultKv := kvReg.FindStringSubmatch(next)
					if len(resultKv) == 4 {
						m[resultKv[2]] = resultComment[2]
						i++
					}
				}
				continue
			}
			// 2.在行的末尾备注，如 k:v  // comment
			resultKvc := kvcReg.FindStringSubmatch(s)
			if len(resultKvc) == 5 {
				m[resultKvc[2]] = resultKvc[4]
			}
		}
	}
	return m
}

// 获取数组内所有的对象，因为有的对象属性不全，所以将数组内对象全返回，然后最后再根据重名对象合并属性
func getArrayObj(raw string) []gjson.Result {
	var res []gjson.Result
	result := gjson.Parse(raw)
	result.ForEach(func(key, value gjson.Result) bool {
		if value.IsObject() {
			parse := gjson.Parse(value.Raw)
			res = append(res, parse)
		}
		return true
	})
	return res
}

// 合并多个value类型，会返回nil
func mergeVType(array []string) string {
	stringFlag := false
	boolFlag := false
	float64Flag := false
	intFlag := false
	int64Flag := false
	anyFlag := false
	nilFlag := false
	for _, t := range array {
		switch t {
		case VTypeString:
			stringFlag = true
		case VTypeBool:
			boolFlag = true
		case VTypeFloat64:
			float64Flag = true
		case VTypeInt:
			intFlag = true
		case VTypeInt64:
			int64Flag = true
		case VTypeAny:
			anyFlag = true
		case VTypeNil:
			nilFlag = true
		}
	}
	if anyFlag {
		return VTypeAny
	}
	count := 0
	// 将这三种类型，统一合并为数字类型
	if float64Flag || intFlag || int64Flag {
		count++
	}
	if stringFlag {
		count++
	}
	if boolFlag {
		count++
	}
	if count > 1 {
		// 代表出现了不同的类型
		return VTypeAny
	}
	if stringFlag {
		return VTypeString
	}
	if boolFlag {
		return VTypeBool
	}
	// 优先级  float64>int64>int
	if float64Flag {
		return VTypeFloat64
	}
	if int64Flag {
		return VTypeInt64
	}
	if intFlag {
		return VTypeInt
	}
	// 空类型优先级最低，这个地方返回空类型，为了后续类型合并使用
	if nilFlag {
		return VTypeNil
	}
	return VTypeAny
}

// 获取json数组属性的类型
func getJSONArrayType(rawArray *gjson.Result) string {
	// 通过数组来推断类型
	array := rawArray.Array()
	var result []string
	for _, a := range array {
		result = append(result, getJSONType(a))
	}
	return mergeVType(result)
}

// 获取json属性的类型
func getJSONType(value gjson.Result) string {
	t := value.Type
	str := VTypeAny
	if t == gjson.Number {
		str = VTypeFloat64
		i := value.Int()
		if float64(i) == value.Float() {
			// 是整数
			if i >= MinInt32 && i <= MaxInt32 {
				str = VTypeInt
			} else {
				str = VTypeInt64
			}
		}
	} else if t == gjson.True || t == gjson.False {
		str = VTypeBool
	} else if t == gjson.String {
		str = VTypeString
	} else if t == gjson.Null {
		str = VTypeNil
	}
	return str
}

func numToLetter(s string) string {
	switch s {
	case "0":
		return "Zero"
	case "1":
		return "One"
	case "2":
		return "Two"
	case "3":
		return "Three"
	case "4":
		return "Four"
	case "5":
		return "Five"
	case "6":
		return "Six"
	case "7":
		return "Seven"
	case "8":
		return "Eight"
	case "9":
		return "Nine"
	}
	return s
}

func convertInitialisms(s string) string {
	upper := strings.ToUpper(s)
	if _, ok := commonInitialisms[upper]; ok {
		return upper
	}
	return s
}
