package core

import (
	"bytes"
	"fmt"
	"go/format"
	"regexp"
	"strconv"
	"strings"
	"unicode"

	"github.com/Lofanmi/pinyin-golang/pinyin"
	"github.com/tidwall/gjson"
)

// 大类型 group
const (
	GroupV    = "Value"
	GroupV1   = "[]Value"
	GroupV2   = "[][]Value"
	GroupO    = "Object"
	GroupO1   = "[]Object"
	GroupO2   = "[][]Object"
	GroupNil1 = "[]"   // 临时类型
	GroupNil2 = "[][]" // 临时类型
)

// 小类型 type
const (
	TypeString  = "string"
	TypeBool    = "bool"
	TypeFloat64 = "float64"
	TypeInt     = "int"
	TypeInt64   = "int64"
	TypeAny     = "interface{}"
	TypeNil     = "nil" // 临时类型，属性为null的，数组为空的，都先用这个表示。最后再进行属性合并的时候会用到
)

const (
	Comment0 = iota
	Comment1
	Comment2
)

const (
	DefaultName = "AutoGenerated"
	DefaultTag  = "json"
	MaxInt32    = 1<<31 - 1
	MinInt32    = -1 << 31
)

// 判断 \g //
var commentReg = regexp.MustCompile(`^(\t*)\s*(//[\s\S]*)$`)

// 判断 \g k:t
var kvReg = regexp.MustCompile(`^(\t*)\"(\S+){1}\": ([\s\S]+){1},?$`)

// 判断 \g k:t // comment
var kvcReg = regexp.MustCompile(`^(\t*)\"(\S+){1}\": ([\s\S]+){1},?\s*(//[\s\S]*)$`)

// https://github.com/golang/lint/blob/master/lint.go
var commonInitialisms = map[string]struct{}{
	"ACL":   {},
	"API":   {},
	"ASCII": {},
	"CPU":   {},
	"CSS":   {},
	"DNS":   {},
	"EOF":   {},
	"GUID":  {},
	"HTML":  {},
	"HTTP":  {},
	"HTTPS": {},
	"ID":    {},
	"IP":    {},
	"JSON":  {},
	"LHS":   {},
	"QPS":   {},
	"RAM":   {},
	"RHS":   {},
	"RPC":   {},
	"SLA":   {},
	"SMTP":  {},
	"SQL":   {},
	"SSH":   {},
	"TCP":   {},
	"TLS":   {},
	"TTL":   {},
	"UDP":   {},
	"UI":    {},
	"UID":   {},
	"UUID":  {},
	"URI":   {},
	"URL":   {},
	"UTF8":  {},
	"VM":    {},
	"XML":   {},
	"XMPP":  {},
	"XSRF":  {},
	"XSS":   {},
}

type Config struct {
	// tags
	Tags []string
	// 0忽略备注，1生成单行备注 2生成行尾备注
	Comment int
	// 是否使用指针
	PointerFlag bool
	// 是否嵌套结构
	NestFlag bool
}

type Node struct {
	// 字段名称
	k string
	// 字段类型
	t string
	// 字段分组，所属大类型
	g string
	// 备注
	c string
	// 嵌套结构
	children *[]*Node
	// 用来merge的
	childrenMerge *[][]*Node
	// childrenMerge 下标使用
	cache map[string]int
}

// Generate json字符串转对象，在前端进行了json5格式验证和格式化
func Generate(jsonStr string, config *Config) (string, error) {
	setJsonTag(config)
	// 解析JSON
	parsedJson := gjson.Parse(jsonStr)
	parent := &Node{k: DefaultName}
	if parsedJson.IsArray() {
		parsedJson.ForEach(func(key, value gjson.Result) bool {
			if value.IsObject() {
				recursionNode(parent, value, config)
			}
			return true
		})
	} else {
		recursionNode(parent, parsedJson, config)
	}
	// 合并数组内的对象和属性
	mergeArrayNode(parent)
	var buff bytes.Buffer
	if config.NestFlag {
		// 嵌套结构体
		buff.WriteString(fmt.Sprintf("type %s ", parent.k))
		nestKey := recursionWrite(parent, config)
		buff.WriteString(nestKey)
	} else {
		all := make([]*Node, 0)
		recursionAdd(&all, parent)
		// 格式化前name；格式化后name
		nameMap := make(map[string]string)
		// 转换后的name，如果重名了，后面加数字表示
		nameCount := make(map[string]int)
		for i, a := range all {
			buff.WriteString(fmt.Sprintf("type %s struct {\n", formatKey(nameMap, nameCount, a.k)))
			for _, node := range *a.children {
				if node.c != "" && config.Comment == Comment1 {
					buff.WriteString(node.c + "\n")
				}
				key := formatKey(nameMap, nameCount, node.k)
				if node.c != "" && config.Comment == Comment2 {
					buff.WriteString(fmt.Sprintf("%s %s %s %s\n", key, formatType(key, node.t, node.g, config.PointerFlag), formatTag(node.k, config.Tags), node.c))
				} else {
					buff.WriteString(fmt.Sprintf("%s %s %s\n", key, formatType(key, node.t, node.g, config.PointerFlag), formatTag(node.k, config.Tags)))
				}
			}
			if i == len(all)-1 {
				buff.WriteString("}")
			} else {
				buff.WriteString("}\n\n")
			}
		}
	}
	source, err := format.Source(buff.Bytes())
	if err != nil {
		fmt.Println(err)
		return buff.String(), err
	}
	return string(source), nil
}

func mergeArrayNode(parent *Node) {
	for _, node := range *parent.childrenMerge {
		addChildren(parent, walkNode(node))
	}
}

// nodes是一个属性
func walkNode(nodes []*Node) *Node {
	parent := mergeNode(nodes)
	if parent.childrenMerge != nil {
		for _, node := range *parent.childrenMerge {
			addChildren(parent, walkNode(node))
		}
	}
	return parent
}

func mergeNode(nodes []*Node) *Node {
	if len(nodes) == 0 {
		return nodes[0]
	}
	n := &Node{k: nodes[0].k}
	group, t := mergeGroupAndType(nodes)
	n.g = group
	n.t = t
	n.c = mergeComment(nodes)
	for _, node := range nodes {
		if node.childrenMerge != nil {
			for _, n1 := range *node.childrenMerge {
				for _, n2 := range n1 {
					addChildrenMerge(n, n2)
				}
			}
		}
	}
	return n
}

func setJsonTag(config *Config) {
	flag := false
	for _, tag := range config.Tags {
		if tag == DefaultTag {
			flag = true
			break
		}
	}
	if !flag {
		if config.Tags == nil {
			config.Tags = make([]string, 0)
		}
		config.Tags = append([]string{DefaultTag}, config.Tags...)
	}
}

func recursionAdd(all *[]*Node, node *Node) {
	if node.children != nil && len(*node.children) > 0 {
		*all = append(*all, node)
		for _, n := range *node.children {
			recursionAdd(all, n)
		}
	}
}

func recursionWrite(parent *Node, config *Config) string {
	// 格式化前name；格式化后name
	nameMap := make(map[string]string)
	// 转换后的name，如果重名了，后面加数字表示
	nameCount := make(map[string]int)
	var res bytes.Buffer
	res.WriteString("struct {\n")
	for _, node := range *parent.children {
		if node.c != "" && config.Comment == Comment1 {
			res.WriteString(node.c + "\n")
		}
		key := formatKey(nameMap, nameCount, node.k)
		nestKey := key
		if node.children != nil && len(*node.children) > 0 {
			nestKey = recursionWrite(node, config)
		}
		if node.c != "" && config.Comment == Comment2 {
			res.WriteString(fmt.Sprintf("%s %s %s %s\n", key, formatType(nestKey, node.t, node.g, config.PointerFlag), formatTag(node.k, config.Tags), node.c))
		} else {
			res.WriteString(fmt.Sprintf("%s %s %s\n", key, formatType(nestKey, node.t, node.g, config.PointerFlag), formatTag(node.k, config.Tags)))
		}
	}
	res.WriteString("}")
	return res.String()
}

func mergeComment(nodes []*Node) string {
	comment := ""
	for _, p := range nodes {
		if p.c != "" {
			comment += p.c + " "
		}
	}
	return strings.Trim(comment, " ")
}

// 返回属性的类型，需要考虑大类型和小类型
func mergeGroupAndType(array []*Node) (group string, t string) {
	var groups []string
	var types []string
	for _, p := range array {
		groups = append(groups, p.g)
		types = append(types, p.t)
	}
	flag, group := mergeFiledGroup(groups)
	if flag {
		// type类型确定
		return group, TypeAny
	}
	if isObject(group) {
		// 对象类型，不需要t
		return group, TypeAny
	}
	// 判断type
	t = mergeFiledType(types, false)
	return group, t
}

// 获取大类型group，判断小类型是否是any
func mergeFiledGroup(array []string) (bool, string) {
	VFlag := false
	V1Flag := false
	V2Flag := false
	OFlag := false
	O1Flag := false
	O2Flag := false
	Nil1Flag := false
	Nil2Flag := false
	for _, g := range array {
		switch g {
		case GroupV:
			VFlag = true
		case GroupV1:
			V1Flag = true
		case GroupV2:
			V2Flag = true
		case GroupO:
			OFlag = true
		case GroupO1:
			O1Flag = true
		case GroupO2:
			O2Flag = true
		case GroupNil1:
			Nil1Flag = true
		case GroupNil2:
			Nil2Flag = true
		}
	}
	count := 0
	if VFlag {
		count++
	}
	if V1Flag {
		count++
	}
	if V2Flag {
		count++
	}
	if OFlag {
		count++
	}
	if O1Flag {
		count++
	}
	if O2Flag {
		count++
	}
	// 类型是any的情况 返回any
	if count > 1 || Nil1Flag && Nil2Flag {
		return true, GroupV
	}
	if Nil1Flag && (VFlag || V2Flag || OFlag || O2Flag) {
		return true, GroupV
	}
	if Nil2Flag && (VFlag || V1Flag || OFlag || O1Flag) {
		return true, GroupV
	}
	if count == 0 {
		if Nil1Flag {
			// 返回 []any
			return true, GroupV1
		} else {
			// 返回 [][]any
			return true, GroupV2
		}
	}
	// 类型不是any
	if VFlag {
		return false, GroupV
	} else if V1Flag {
		// 不需要考虑Nil1Flag
		return false, GroupV1
	} else if V2Flag {
		return false, GroupV2
	} else if OFlag {
		return false, GroupO
	} else if O1Flag {
		return false, GroupO1
	} else {
		return false, GroupO2
	}
}

// 格式化对象名，属性名，并且通过cache来解决全局重名问题
// 对象名不能重复；属性名要考虑多个对象之间的一致性，所以要保持全局统一的映射关系
func formatKey(nameMap map[string]string, nameCount map[string]int, key string) string {
	if e, ok := nameMap[key]; ok {
		return e
	}
	result := ""
	// 按下划线分割，每个片段的首字母大写
	split := strings.Split(key, "_")
	for i, str := range split {
		span := ""
		for j, v := range str {
			s := ""
			if isLetter(v) {
				s = string(v)
			} else if isDigit(v) {
				s = string(v)
			} else if unicode.Is(unicode.Han, v) {
				// 处理中文字符
				s = convert2Pinyin(string(v))
			}
			if s == "" {
				continue
			}
			if j == 0 {
				s = strings.ToUpper(s)
			}
			if i == 0 && span == "" {
				// 首字母如果是数字，就转换
				s = numToLetter(s)
			}
			span += s
		}
		span = convertInitialisms(span)
		result += span
	}
	result = convertInitialisms(result)
	// 判断是否重名
	if count, ok := nameCount[result]; ok {
		// 重名了，末尾加数字
		result = result + strconv.Itoa(count+1)
		nameCount[result] = count + 1
	} else {
		nameCount[result] = 0
	}
	nameMap[key] = result
	return result
}

func isLetter(r rune) bool {
	return r >= 'a' && r <= 'z' || r >= 'A' && r <= 'Z'
}

func isDigit(r rune) bool {
	return r >= '0' && r <= '9'
}

// 中文字符转拼音首字母，返回小写
func convert2Pinyin(s string) string {
	s = pinyin.NewDict().Abbr(s, "")
	return strings.ToLower(s)
}

// 格式化完整的类型
func formatType(key string, t string, group string, pointerFlag bool) string {
	result := t
	pointer := ""
	if pointerFlag {
		pointer = "*"
	}
	if group == GroupO {
		result = pointer + key
	} else if group == GroupO1 {
		result = "[]" + pointer + key
	} else if group == GroupO2 {
		result = "[][]" + pointer + key
	} else if group == GroupV1 {
		result = "[]" + t
	} else if group == GroupV2 {
		result = "[][]" + t
	}
	return result
}

// 格式化tag
func formatTag(key string, tag []string) string {
	result := "`"
	var array []string
	for _, t := range tag {
		s := fmt.Sprintf("%s:%q", t, key)
		array = append(array, s)
	}
	result += strings.Join(array, " ")
	result += "`"
	return result
}

func recursionNode(parent *Node, result1 gjson.Result, config *Config) {
	cm := make(map[string]string)
	if config.Comment != Comment0 {
		cm = buildCommentMap(result1)
	}
	result1.ForEach(func(key1, value1 gjson.Result) bool {
		if value1.Type == gjson.JSON {
			if value1.IsArray() {
				// 一维数组
				if value1.Raw == "[]" {
					addChildrenMerge(parent, &Node{k: key1.String(), t: TypeNil, g: GroupNil1, c: cm[key1.String()]})
					return true
				}
				result2 := gjson.Parse(value1.Raw)
				result2.ForEach(func(key2, value2 gjson.Result) bool {
					if value2.Type == gjson.JSON {
						if value2.IsArray() {
							// 二维数组
							if value2.Raw == "[]" {
								addChildrenMerge(parent, &Node{k: key1.String(), t: TypeNil, g: GroupNil2, c: cm[key1.String()]})
								return false
							}
							result3 := gjson.Parse(value2.Raw)
							result3.ForEach(func(key3, value3 gjson.Result) bool {
								if value3.Type == gjson.JSON {
									if value3.IsObject() {
										// [][]Object
										node := &Node{k: key1.String(), t: key1.String(), g: GroupO2, c: cm[key1.String()]}
										addChildrenMerge(parent, node)
										arrayObj := getArrayObj(value2)
										for _, obj := range arrayObj {
											recursionNode(node, obj, config)
										}
										return false
									}
								} else {
									// [][]Value
									addChildrenMerge(parent, &Node{k: key1.String(), t: getJSONArrayType(&result3), g: GroupV2, c: cm[key1.String()]})
									return false
								}
								return false
							})
						} else if value2.IsObject() {
							// []Object
							node := &Node{k: key1.String(), t: key1.String(), g: GroupO1, c: cm[key1.String()]}
							addChildrenMerge(parent, node)
							arrayObj := getArrayObj(value1)
							for _, obj := range arrayObj {
								recursionNode(node, obj, config)
							}
						}
					} else {
						// []Value
						addChildrenMerge(parent, &Node{k: key1.String(), t: getJSONArrayType(&result2), g: GroupV1, c: cm[key1.String()]})
					}
					return false
				})
			} else if value1.IsObject() {
				// Object
				node := &Node{k: key1.String(), t: key1.String(), g: GroupO, c: cm[key1.String()]}
				addChildrenMerge(parent, node)
				recursionNode(node, value1, config)
			}
		} else {
			// Value
			addChildrenMerge(parent, &Node{k: key1.String(), t: getJSONType(value1), g: GroupV, c: cm[key1.String()]})
		}
		return true
	})
}

func addChildren(parent *Node, node *Node) {
	if parent.children == nil {
		children := make([]*Node, 0)
		parent.children = &children
	}
	*parent.children = append(*parent.children, node)
}

func addChildrenMerge(parent *Node, node *Node) {
	if parent.childrenMerge == nil {
		children := make([][]*Node, 0)
		parent.childrenMerge = &children
		parent.cache = make(map[string]int)
	}
	if index, ok := parent.cache[node.k]; ok {
		(*parent.childrenMerge)[index] = append((*parent.childrenMerge)[index], node)
	} else {
		length := len(*parent.childrenMerge)
		*parent.childrenMerge = append(*parent.childrenMerge, []*Node{node})
		parent.cache[node.k] = length
	}
}

// 支持单行备注，每次都是全量按行遍历，根据前缀\t的个数，来决定是否是最外层对象的备注
func buildCommentMap(result gjson.Result) map[string]string {
	m := make(map[string]string)
	raw := result.Raw
	if !strings.Contains(raw, "//") {
		return m
	}
	firstKey := ""
	prefix := "-"
	result.ForEach(func(key, value gjson.Result) bool {
		firstKey = key.Str
		return false
	})
	split := strings.Split(raw, "\n")
	// 判断第一个key的前缀，有几个\t
	for _, s := range split {
		resultKv := kvReg.FindStringSubmatch(s)
		if len(resultKv) == 4 {
			if resultKv[2] == firstKey {
				prefix = resultKv[1]
				break
			}
		}
		resultKvc := kvcReg.FindStringSubmatch(s)
		if len(resultKvc) == 5 {
			if resultKvc[2] == firstKey {
				prefix = resultKvc[1]
				break
			}
		}
	}
	if prefix == "-" {
		// 没有解析到key
		return m
	}
	k1 := prefix
	k2 := prefix + "\t"
	for i := 0; i < len(split); i++ {
		s := split[i]
		// 以\t开头的，先通过前缀筛选数据，然后在进行正则匹配
		if strings.HasPrefix(s, k1) && !strings.HasPrefix(s, k2) {
			// 1.在行的上一行进行备注，如  // 独立一行的备注
			resultComment := commentReg.FindStringSubmatch(s)
			if len(resultComment) == 3 {
				// 判断下一行是不是json的kv
				if i <= len(split)-2 {
					next := split[i+1]
					resultKv := kvReg.FindStringSubmatch(next)
					if len(resultKv) == 4 {
						m[resultKv[2]] = resultComment[2]
						i++
					}
				}
				continue
			}
			// 2.在行的末尾备注，如 k:v  // comment
			resultKvc := kvcReg.FindStringSubmatch(s)
			if len(resultKvc) == 5 {
				m[resultKvc[2]] = resultKvc[4]
			}
		}
	}
	return m
}

// 获取数组内所有的对象，因为有的对象属性不全，所以将数组内对象全返回
func getArrayObj(result gjson.Result) []gjson.Result {
	var res []gjson.Result
	result.ForEach(func(key, value gjson.Result) bool {
		if value.IsObject() {
			res = append(res, value)
		}
		return true
	})
	return res
}

// 合并多个type类型
func mergeFiledType(array []string, flag bool) string {
	stringFlag := false
	boolFlag := false
	float64Flag := false
	intFlag := false
	int64Flag := false
	anyFlag := false
	nilFlag := false
	for _, t := range array {
		switch t {
		case TypeString:
			stringFlag = true
		case TypeBool:
			boolFlag = true
		case TypeFloat64:
			float64Flag = true
		case TypeInt:
			intFlag = true
		case TypeInt64:
			int64Flag = true
		case TypeAny:
			anyFlag = true
		case TypeNil:
			nilFlag = true
		}
	}
	if anyFlag {
		return TypeAny
	}
	count := 0
	// 将这三种类型，统一合并为数字类型
	if float64Flag || intFlag || int64Flag {
		count++
	}
	if stringFlag {
		count++
	}
	if boolFlag {
		count++
	}
	if count > 1 {
		// 代表出现了不同的类型
		return TypeAny
	}
	if stringFlag {
		return TypeString
	} else if boolFlag {
		return TypeBool
	} else if float64Flag {
		// 优先级  float64>int64>int
		return TypeFloat64
	} else if int64Flag {
		return TypeInt64
	} else if intFlag {
		return TypeInt
	} else if nilFlag {
		// 空类型优先级最低，这个地方返回空类型，为了后续类型合并使用
		if flag {
			return TypeNil
		}
		return TypeAny
	}
	return TypeAny
}

// 获取json数组属性的类型
func getJSONArrayType(rawArray *gjson.Result) string {
	// 通过数组来推断类型
	array := rawArray.Array()
	var result []string
	for _, a := range array {
		result = append(result, getJSONType(a))
	}
	return mergeFiledType(result, true)
}

// 获取json属性的类型
func getJSONType(value gjson.Result) string {
	t := value.Type
	str := TypeAny
	if t == gjson.Number {
		str = TypeFloat64
		i := value.Int()
		if float64(i) == value.Float() {
			// 是整数
			if i >= MinInt32 && i <= MaxInt32 {
				str = TypeInt
			} else {
				str = TypeInt64
			}
		}
	} else if t == gjson.True || t == gjson.False {
		str = TypeBool
	} else if t == gjson.String {
		str = TypeString
	} else if t == gjson.Null {
		str = TypeNil
	}
	return str
}

func numToLetter(s string) string {
	switch s {
	case "0":
		return "Zero"
	case "1":
		return "One"
	case "2":
		return "Two"
	case "3":
		return "Three"
	case "4":
		return "Four"
	case "5":
		return "Five"
	case "6":
		return "Six"
	case "7":
		return "Seven"
	case "8":
		return "Eight"
	case "9":
		return "Nine"
	}
	return s
}

func convertInitialisms(s string) string {
	upper := strings.ToUpper(s)
	if _, ok := commonInitialisms[upper]; ok {
		return upper
	}
	return s
}

func isObject(group string) bool {
	if group == GroupO || group == GroupO1 || group == GroupO2 {
		return true
	}
	return false
}
