package core

import (
	"strings"
	"testing"
)

func TestGenerate(t *testing.T) {
	type args struct {
		jsonStr string
		config  *Config
	}
	tests := []struct {
		name    string
		args    args
		want    string
		wantErr bool
	}{
		{
			name: "web使用的测试case",
			args: args{
				jsonStr: `{
	// 1.支持单行备注提取，可在上一行或行尾
	"k1": "v1",
	"k2": "v2", // 行尾备注
	"k3": {
		"k3_1": {
			"k3_1_1": "" // 递归解析备注
		}
	},
	"k4": [{ // 数组类型备注
		"k41": ""
	}, {
		"k41": "" // 备注合并
	}],
	// 2.支持属性名格式化，支持中文
	"地址": "山东枣庄",
	"地质": "中文解析后重名了，自动数字编号",
	"中文++))": "自动忽略不识别的字符",
	"id": "golint代码检查优化",
	"user_name": "",
	"3只松鼠": "",
	// 3.支持属性类型推断，单独属性，数组内属性，同名对象属性
	"float": 1.15,
	"arrayFloat": [1, 2.1],
	"arrayObjFloat1": [{
		"cost": 10
	}, {
		"cost": 10.2
	}],
	"arrayObjFloat2": [
		[{
			"cost": 10
		}, {
			"cost": 10.2
		}]
	],
	// 4.支持对象属性合并
	"questionArray": [{
			"type": "select",
			"props": {
				"info": ""
			},
			"options": [],
			"other": null
		},
		{
			"type": "select",
			"props": {
				"info": "",
				"value": ""
			},
			"options": [{
				"label": "",
				"value": ""
			}],
			"other": "",
			"required": false
		}
	]
}`,
				config: &Config{
					Comment:  Comment1,
					NestFlag: false,
				},
			},
			want: `type AutoGenerated struct {
	// 1.支持单行备注提取，可在上一行或行尾
	K1 string |json:"k1"|
	// 行尾备注
	K2 string |json:"k2"|
	K3 K3     |json:"k3"|
	// 数组类型备注
	K4 []K4 |json:"k4"|
	// 2.支持属性名格式化，支持中文
	Dz       string |json:"地址"|
	Dz1      string |json:"地质"|
	Zw       string |json:"中文++))"|
	ID       string |json:"id"|
	UserName string |json:"user_name"|
	Threezss string |json:"3只松鼠"|
	// 3.支持属性类型推断，单独属性，数组内属性，同名对象属性
	Float          float64            |json:"float"|
	ArrayFloat     []float64          |json:"arrayFloat"|
	ArrayObjFloat1 []ArrayObjFloat1   |json:"arrayObjFloat1"|
	ArrayObjFloat2 [][]ArrayObjFloat2 |json:"arrayObjFloat2"|
	// 4.支持对象属性合并
	QuestionArray []QuestionArray |json:"questionArray"|
}

type K3 struct {
	K31 K31 |json:"k3_1"|
}

type K31 struct {
	// 递归解析备注
	K311 string |json:"k3_1_1"|
}

type K4 struct {
	// 备注合并
	K41 string |json:"k41"|
}

type ArrayObjFloat1 struct {
	Cost float64 |json:"cost"|
}

type ArrayObjFloat2 struct {
	Cost float64 |json:"cost"|
}

type QuestionArray struct {
	Type     string    |json:"type"|
	Props    Props     |json:"props"|
	Options  []Options |json:"options"|
	Other    string    |json:"other"|
	Required bool      |json:"required"|
}

type Props struct {
	Info  string |json:"info"|
	Value string |json:"value"|
}

type Options struct {
	Label string |json:"label"|
	Value string |json:"value"|
}`,
			wantErr: false,
		},
		{
			name: "测试备注",
			args: args{
				jsonStr: `{
	// 1.支持单行备注提取，可在上一行或行尾
	"k1": "v1",
	"k2": "v2", // 行尾备注
	"k3": {
		"k3_1": {
			"k3_1_1": "" // 递归解析备注
		}
	},
	"k4": [{ // 数组类型备注
		"k41": ""
	}, {
		"k41": "" // 备注合并
	}]
}`,
				config: &Config{
					Comment:  Comment1,
					NestFlag: false,
				},
			},
			want: `type AutoGenerated struct {
	// 1.支持单行备注提取，可在上一行或行尾
	K1 string |json:"k1"|
	// 行尾备注
	K2 string |json:"k2"|
	K3 K3     |json:"k3"|
	// 数组类型备注
	K4 []K4 |json:"k4"|
}

type K3 struct {
	K31 K31 |json:"k3_1"|
}

type K31 struct {
	// 递归解析备注
	K311 string |json:"k3_1_1"|
}

type K4 struct {
	// 备注合并
	K41 string |json:"k41"|
}`,
			wantErr: false,
		},
		{
			name: "测试备注中带双引号，会导致解析异常，使用时注意这种情况",
			args: args{
				jsonStr: `{
	"a": "", // 备注 ""
	"b": "", // 备注 ""
	"c": "", // 备注 ""
}`,
				config: &Config{
					Comment:  Comment0,
					NestFlag: false,
				},
			},
			want: `type AutoGenerated struct {
	A      string |json:"a"|
	string |json:""|
	C      string |json:"c"|
}`,
			wantErr: false,
		},
		{
			name: "测试属性的命名，支持中文，处理特殊字符",
			args: args{
				jsonStr: `{
	"地址": "山东枣庄",
	"地质": "中文解析后重名了，自动数字编号",
	"中文++))": "自动忽略不识别的字符",
	"id": "golint代码检查优化",
	"user_name": "",
	"3只松鼠": ""
}`,
				config: &Config{
					Comment:  Comment1,
					NestFlag: false,
				},
			},
			want: `type AutoGenerated struct {
	Dz       string |json:"地址"|
	Dz1      string |json:"地质"|
	Zw       string |json:"中文++))"|
	ID       string |json:"id"|
	UserName string |json:"user_name"|
	Threezss string |json:"3只松鼠"|
}`,
			wantErr: false,
		},
		{
			name: "测试属性类型推断",
			args: args{
				jsonStr: `{
	"float": 1.15,
	"arrayFloat": [1, 2.1],
	"arrayObjFloat1": [{
		"cost": 10
	}, {
		"cost": 10.2
	}],
	"arrayObjFloat2": [
		[{
			"cost": 10
		}, {
			"cost": 10.2
		}]
	]
}`,
				config: &Config{
					Comment:  Comment1,
					NestFlag: false,
				},
			},
			want: `type AutoGenerated struct {
	Float          float64            |json:"float"|
	ArrayFloat     []float64          |json:"arrayFloat"|
	ArrayObjFloat1 []ArrayObjFloat1   |json:"arrayObjFloat1"|
	ArrayObjFloat2 [][]ArrayObjFloat2 |json:"arrayObjFloat2"|
}

type ArrayObjFloat1 struct {
	Cost float64 |json:"cost"|
}

type ArrayObjFloat2 struct {
	Cost float64 |json:"cost"|
}`,
			wantErr: false,
		},
		{
			name: "测试对象的合并，同一个属性出现多个类型时，依赖类型判断来推断",
			args: args{
				jsonStr: `{
	"questionArray": [{
			"type": "select",
			"props": {
				"info": ""
			},
			"options": [],
			"other": null
		},
		{
			"type": "select",
			"props": {
				"info": "",
				"value": ""
			},
			"options": [{
				"label": "",
				"value": ""
			}],
			"other": "",
			"required": false
		}
	]
}`,
				config: &Config{
					Comment:  Comment1,
					NestFlag: false,
				},
			},
			want: `type AutoGenerated struct {
	QuestionArray []QuestionArray |json:"questionArray"|
}

type QuestionArray struct {
	Type     string    |json:"type"|
	Props    Props     |json:"props"|
	Options  []Options |json:"options"|
	Other    string    |json:"other"|
	Required bool      |json:"required"|
}

type Props struct {
	Info  string |json:"info"|
	Value string |json:"value"|
}

type Options struct {
	Label string |json:"label"|
	Value string |json:"value"|
}`,
			wantErr: false,
		},
		{
			name: "测试空值，空数组的处理",
			args: args{
				jsonStr: `{
	"array": [{
		"options": [],
		"other": null
	}],
	"obj": {
		"options": [],
		"other": null
	},
	"options": [],
	"other": null
}`,
				config: &Config{
					Comment:  Comment1,
					NestFlag: false,
				},
			},
			want: `type AutoGenerated struct {
	Array   []Array       |json:"array"|
	Obj     Obj           |json:"obj"|
	Options []interface{} |json:"options"|
	Other   interface{}   |json:"other"|
}

type Array struct {
	Options []interface{} |json:"options"|
	Other   interface{}   |json:"other"|
}

type Obj struct {
	Options []interface{} |json:"options"|
	Other   interface{}   |json:"other"|
}`,
			wantErr: false,
		},
		{
			name: "测试入参是数组的情况",
			args: args{
				jsonStr: `[{
 	"id": 1,
 	"name": ""
 }, {
 	"id": 1,
 	"name": "",
 	"location": {
 		"province": "",
 		"city": ""
 	}
 }]`,
				config: &Config{
					Comment:  Comment1,
					NestFlag: false,
				},
			},
			want: `type AutoGenerated struct {
	ID       int      |json:"id"|
	Name     string   |json:"name"|
	Location Location |json:"location"|
}

type Location struct {
	Province string |json:"province"|
	City     string |json:"city"|
}`,
			wantErr: false,
		},
		{
			name: "测试使用指针",
			args: args{
				jsonStr: `{
	"location": {
		"province": ""
	},
	"location1": [{
		"province": ""
	}],
	"location2": [
		[{
			"province": ""
		}]
	]
}`,
				config: &Config{
					Comment:     Comment1,
					PointerFlag: true,
				},
			},
			want: `type AutoGenerated struct {
	Location  *Location      |json:"location"|
	Location1 []*Location1   |json:"location1"|
	Location2 [][]*Location2 |json:"location2"|
}

type Location struct {
	Province string |json:"province"|
}

type Location1 struct {
	Province string |json:"province"|
}

type Location2 struct {
	Province string |json:"province"|
}`,
			wantErr: false,
		},
		{
			name: "测试数组属性合并",
			args: args{
				jsonStr: `{
	"a": [{
		"a1": {
			"a2": [{
				"a3": ""
			}, {
				"b3": ""
			}]
		}
	}, {
		"a1": {
			"a2": [{
				"a3": ""
			}, {
				"c3": ""
			}],
			"d2": "3"
		},
		"b1": {
			"b2": "3"
		}
	}],
	"b": 1
}`,
				config: &Config{
					Comment:  Comment1,
					NestFlag: true,
				},
			},
			want: `type AutoGenerated struct {
	A []struct {
		A1 struct {
			A2 []struct {
				A3 string |json:"a3"|
				B3 string |json:"b3"|
				C3 string |json:"c3"|
			} |json:"a2"|
			D2 string |json:"d2"|
		} |json:"a1"|
		B1 struct {
			B2 string |json:"b2"|
		} |json:"b1"|
	} |json:"a"|
	B int |json:"b"|
}`,
			wantErr: false,
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			got, err := Generate(tt.args.jsonStr, tt.args.config)
			if (err != nil) != tt.wantErr {
				t.Errorf("Generate() error = %v, wantErr %v", err, tt.wantErr)
				return
			}
			if got != strings.ReplaceAll(tt.want, "|", "`") {
				t.Errorf("Generate() got = %s, want %s", got, tt.want)
			}
		})
	}
}
